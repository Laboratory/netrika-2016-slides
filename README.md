# FP for Rubyists

Представьте, что вы задремали в кулуарах RailsClub, но вдруг мимо вас пробежал Николай Рыжиков во второй зал.

Он представился художественным руководителем команды Health-Samurai, которая уже лет 8 занимается Health IT. Он шептал какие-то странные слова - ФП, персистентные структуры данных. И вы, не подумав про последствия, побежали за ним и ... провалились в кроличью нору (хотя Ярослав вас предупреждал:).

То ли нора была слишком глубокой, то ли ... Николай слишком долго говорил, но на 40 минут вы попали в страну Функционального программирования.

Вокруг все было похожим на привычную обстановку, но все было каким-то странным.

Во-первых, все было сделано из функций и данных. Да-да все было наоборот - мы стремимся связать поведение и данные в аккуратненькие объекты, а у них проводилась четкая грань между ними. Функции чем-то напоминали
наши методы, лямбды и блоки, но тоже были странными. 
И почему-то поблизости практически не было никаких объектов и классов.

Почему-то вокруг все говорили не "передать аргументы в функцию", а применить функцию к значениям (так там называли данные).

То ли потому, что функции за собой ухаживали, но они считали себя "чистыми" и вели они себя
необычно. Например, функция ```inc`` применялась к единичке и возвращала двойку, но единичка
тоже никуда не исчезала. У нас тоже есть операторы над примитивными типами, они ведут себя так же.
Но здесь, даже такие с виду знакомые функции как ```push``` элемента в массив, ничего не делали
с оригинальным массивом и элементом, а возвращали новый массив, содержащий элемент (как будто делали
копию). Так же вела себя функция добавления нового ключа в ```hash``.

Здесь вообще нельзя было поменять что-нибудь в данных. При любой попытке мы получали каждый раз новую измененную копию, но и старые данные тоже оставались на своих местах. Возможно поэтому функции называли чистыми, а данные значениями.

Мы попробовали несколько раз применить функцию к тем же самым значениям, но результат был всегда
одним и тем же (даже не интересно). Вне зависимости от того, что происходило вокруг, эти "чистые" функции
постоянно, как автоматы, возвращали то же самое. Хоть не вызывай их второй раз с теми же аргументами, 
а просто замени предыдущим результатом. За такое поведение они считали себя ссылочно-прозрачными — т.е. во всех местах и в любое время можно было заменить вызов функции с одинаковыми параметрами тем, что они возвращают, и ничего бы не поменялось.

Эти функции подозрительно легко склеивались, достаточно было выход одной функции соединить со входом другой (если подходили разъемы) и мы получали новую функцию, которая опять оказывалась чистой.

Вообще все программы строились как дерево соединенных подобным образом функций (у нас это обычно граф объектов). Стоило передать в такое дерево входные данные, они начинали передаваться вверх достигая листиков, а потом листики начинали схлопываться в данные.
И когда все листики на веточке схлопывались, веточка превращалась в листик и тоже начинала схлопываться. И в итоге от дерева оставалось только значение. Они называли это evaluation. Причем оказывалось не очень важно в каком порядке схлопываются веточки, поскольку в результате все равно получалось то же самое значение.

У них была своя абстрактократия: некоторые функции могли принимать на вход другие функции или производить новые функции, их называли функциями высших порядков.

....

Например, была функция Fold (или reduce), при помощи которой можно было выполнить практически любые операции с коллекциями: получить сумму, произведение, смапить, отфильтровать. Похожие функции были для работы с деревьями. Они уже принимали по несколько других функций. Ну, у нас есть нечто похожее, иногда называют потоками.

Были еще забавные функции, которые могли оборачивать другие функции, т.е. они принимали функцию, возвращая новую функцию. Это чем-то напоминало наш паттерн декоратор. Из подобных функций можно было собрать новую, нанизывая их друг на друга и добавляя новую функциональность, а потом применять ее к значениям.

Например у нас на глазах, для последовательного применения различных операций к коллекциям, вместо того чтобы применять каждую операцию обегая коллекцию каждый раз, они вначале собрали из таких декорирующих функций новую, содержащую все нужные операции, и лишь потом применили ее к коллекции за один проход. Им даже не понадобились ленивые коллекции, чтобы сделать это. Некоторые называли эти странные декорируемые функции для работы с коллекциями - трансдьюсерами.

Еще, кстати, там были изменяемые данные и всякие вводы-выводы, но их считали дикими и опасными и поэтому изолировали от общества чистых функций и данных-значений. Они сидели в клетках, которые называли SТМ или IO монады, трогать их можно было только в транзакции изолированной от остального мира, ну или вообще нельзя было.

Когда несколько функций начинали работать одновременно, они вообще друг другу не мешали, поскольку у каждой были свои копии игрушек. А если им нужен был доступ к зверям, то под чутким контролем STM почему-то не удавалось устроить им гонку или не консистентное чтение или дедлок. Так что было даже не интересно - никакого риска и адреналина.

Мы как веб-программисты, конечно же отправились туда, где из этих функций делают веб-приложения.

Веб сервер
Роутинг
Вью
Генерация SQL
Сервисы и контроллеры
Весь стэк
